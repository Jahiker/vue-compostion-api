# VUE JS, OPTION API Y COMPOSITION API

## Options API 
-- Podemos crear componentes completo desde la configuracion de un objeto json 

## Composition API 
-- Tiene una estructura mas parecida a la programacion funcional y el codigo es mucho mas organizado

## Styles in components 
-- Los estilos que se definen en un componente, se definen como estilos globales
-- para delimitar los estilos, unicamente al componente se utiliza el atributo scoped => <style scoped>

## Component <componenet :is=""></componenet>
-- es un componente que se puede comportar como cualquier otro componente que reciba en la directiva :is 

## Componentes asincronos
-- Vue nos proporciona una funcion => defineAsyncComponent
-- esta nos permite cargar los componentes de forma asincrona solo cuando son necesarios y asi ayudar al performance del sitio.

## Componente transition
-- Es un componente que permite agregar animaciones css 
-- Se le coloca un name al componente y esa sera la clase identificadora para establecer animaciones 

## Teleports
-- Es un tipo de componente espacial y permite que un componente definido pueda mostrarse en otra parte del documento

## Virtual DOM (Virtual Document Object Model)
-- Es una capa intermedia entre el template y el DOM hecha con javascript
-- Es una copia del DOM que vive en la memoria RAM
-- Es mas facil de acceder y modificar el el DOM porque es un objeto JS 

## Ciclo de vida de los componentes 
-- beforeCreate: antes de que se comience a crear el componente 
-- created: el componente ya esta creado mas no existe en el DOM 
-- beforeMount: antes de montar el componente en el DOM 
-- mounted: ya esta el componente montado 
-- beforeUpdate: antes de que suceda cualquier modificacion del componente 
-- updated: ya el componen: antes de que se destruyate se ha actualizado
-- beforeUnmount: antes de que se destruya el componente
-- unmounted: ya fue destruido el componente 

## Mixins 
-- Es una opcion disponible en la Options API de vue 
-- Nos permite combinar los json de la options API para poder crear componentes genericos 
-- estos componentes al ser genericos son reutilizables y a travez de atributos y metodos defines la forma del componente como lo requieras (Es como una especie de herencia o composicion de componentes)
-- Como desventaja tenemos que no sabemos que hay en el mixins hasta que abres su codigo 
-- como no hay visibilidad directa es un poco dificil debuggear
-- a partir de la version 3 ya no son necesarios por que se cuenta con el composition API 

## Composition API
-- Todo parte desde la funcion setup, que es una funcion que se ejecuta al inicio del ciclo de vida del componente
-- La funcion setup recibe por defecto dos argumentos las props y ctx (contexto) 
-- La funcion setup retorna todo lo que quieras exporner accerca del componente 
-- con la composition API puedes acceder a todos los elementos de ciclo de vida de un componentes menos al beforeCreate y created porque son remmplazados por la funcion setup()
-- La funcion setup por ejecutarse antes del ciclo de vida de Vue, no tendra acceso a datos como el atributo $el, ref, $data, funciones computadas definidas en la opcions API y los methods, esto se debe a que no  podemos acceder a this, entonces todo lo que requiera el uso de this es inaccesible en la funcion setup  

## Variables reactivas
-- ref: nos da una referencia reactiva a un dato primitivo o una variable
-- reactive: es igual que ref pero para datos tipo objetos

###################################################################
# NOTAS DEL PROFESOR

La reactividad de VueJS es posible gracias al objeto Proxy en JavaScript.
Proxy nos permite crear una referencia a otro objeto, que se comportará igual que si se tratara del objeto original, pero agregando la capacidad de escuchar cada vez que un valor del objeto cambia para ejecutar algún código.

De hecho, cada cambio que hacemos sobre un objeto Proxy, en realidad se aplica al objeto original, aún así, para JS se sigue tratando de dos objetos distintos, por lo que si aplicamos un cambio al objeto original, el objeto Proxy no se enterará, es decir, el valor si se verá reflejado al accederlo, pero los handlers que escuchan esos cambios no se activarán.

``// Ejemplo de proxy
// Se define el objeto original
const obj = {
  counter: 0
};

/*
 Se definen los handlers,
 que escucharán todo lo que suceda con el objeto original.
*/
const handlers = {
  /* 
    Este handler escucha cada vez que
    asignamos un nuevo valor a un atributo del objeto original.
  */
  set(obj, prop, val) {
    /*
      obj: refiere al objeto original
      prop: es el atributo del objeto, por ejemplo: counter
    */
     console.log(`update: ${prop}`);
  }
}

    // Creamos un proxy de obj
    const proxy = new Proxy(obj, handlers);

    // Ejecutamos lo siguiente en la consola
    obj.counter 
    output: 0

    proxy.counter
    output: 0

    // el handler no se ejecuta
    obj.counter++

    obj.counter
    output: 1

    proxy.counter
    output: 1

    // el handler si se ejecuta
    proxy.counter++
    output: update counter

    obj.counter
    output: 2

    proxy.counter
    output: 2``

Es gracias al objeto Proxy, que VueJS puede saber que un valor ha cambiado y así propagar ese cambio a todos los lugares dónde se use ese valor, esto es a lo que conocemos cómo reactividad.

Sin embargo, el objeto Proxy tiene ciertas reglas para funcionar, la principal es que necesita envolver a un objeto, no puede funcionar sobre variables que solo tengan valores de tipo primitivo (números, cadenas de texto, booleanos, etc).

Es por eso que cuándo se trata de valores de tipo primitivo, cómo es el caso de la función ref, siempre tenemos que usar el atributo value para acceder al valor y así mantener la reactividad, pues por detrás estará creando un objeto con la propiedad value, a la cuál le asignará el valor que ref recibe por argumento.

``// Podemos imaginar el código de ref más o menos así
function ref(value) {
  return new Proxy({ value }, {
    set(obj, prop, val) {
  	/* Aquí vue escucha cuándo asignamos un nuevo valor */
    }
  });
}

// Uso
const counter = ref(0);
counter.value = 10;
console.log(counter.value); // output 10``

Mientras tanto cuándo usamos reactive, el valor que pasamos por argumento ya es un objeto, así que VueJS puede aplicarle todo su sistema de reactividad sin necesidad de hacer nada más.

``
// Podemos imaginar el código de reactive más o menos así
function ref(value) {
  return new Proxy(value, {
    set(obj, prop, val) {
  	/* Aquí vue escucha cuándo asignamos un nuevo valor */
    }
  });
}

// Uso
const obj = reactive({ counter: 0 });
obj.counter = 10;
console.log(obj.counter); // output 10
``

Es por esto que en variables creadas con ref necesitamos usar el atributo value, pero en variables creadas con reactive, no es necesario.

Esto también significa que debemos tener cuidado al usar cosas cómo el spread operator (…), ya que estaríamos extrayendo el valor del objeto Proxy, y por lo tanto obtenemos el valor, más no la referencia, y podemos perder la reactividad.

###################################################################

## Watch
-- Es uan funcion que observa cambios sobre una avriables y ejecuta una funcion cada vez que el valor cambie 
-- La funcion que ejecuta watch recibe 2 argumentos, el nuevo valor y el valor anterior de la variable

## props
-- Se recibe el objeto props fuera de la funcion setup 
-- La funcion setup recibe las props como atributo
-- Para que las props sean reactivas ultilizamos el hook toRefs para convertir objetos planos en reactivos 

## Context 
-- El contexto no das mas informacion sobre el componente 
-- attrs (attributes): son los atributos que del componehte que no sean declarados como props 
-- emit: son eventos personalizados que va a emitir el componente 
-- expose: es una funcion que podemos usar una sola vez dentro del componente y nos permite exponer variables y valores que son internos que pertenencen al scope del componente y asi poder acceder a ellos fuera del componente 
-- slots: contiene los slots que puede recibir el componente 

## Provide - Inject
-- Nos permite la comunicacion de props con componentes de mayor profundidad a un hijo 
-- Provide se define dentro del Setup dentro del componente principal App
-- El inject se usa dentro de los componentes descendientes y se asigan el valor a una variable 

## Refs 
